{"version":3,"file":"grechabuf.min.cjs","sources":["../../grechabuf.ts"],"sourcesContent":["export interface FieldSerializeResult<T> {\n    data: T,\n    length: number\n}\n\nexport interface Field<T> {\n    /**\n     * Calculate byte size\n     *\n     * @param value {T} value\n     *\n     * @returns {number} minimal field length\n     */\n    size(value: T): number\n\n    /**\n     * Serialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     * @param value {T} value to serialize\n     *\n     * @returns {number} size of written field\n     */\n    serialize(view: DataView, position: number, value: T): number\n\n    /**\n     * Deserialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} size of written field\n     */\n    deserialize(view: DataView, position: number): FieldSerializeResult<T>\n}\n\ntype Fields = Record<string, Field<any>>\n\ntype InferFieldsValues<T extends Fields> = {\n    [K in keyof T]: T[K] extends Field<infer U> ? U : never;\n};\n\n/**\n * Struct declaration\n *\n * Used for serializing/deserializing structs\n */\nexport interface Struct<F extends Fields> {\n    /**\n     * Calculate size of buffer\n     *\n     * @returns {number} size of buffer\n     */\n    size(data: InferFieldsValues<F>): number,\n\n    /**\n     * Serialize struct, returning with new ArrayBuffer\n     *\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {ArrayBuffer} serialized data\n     */\n    serialize(data: InferFieldsValues<F>): ArrayBuffer\n\n    /**\n     * Serialize struct into data view\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    serializeInto(view: DataView, data: InferFieldsValues<F>): number\n\n    /**\n     * Deserialize struct from data view\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    deserialize(view: DataView, position?: number): InferFieldsValues<F>\n}\n\n/**\n*\n* @param fields {{[name: string]: Field }}\n* @returns {Struct} created struct declaration\n*/\nexport function createStruct<F extends Fields>(fields: F): Struct<F> {\n    return {\n        size(data: InferFieldsValues<F>) {\n            let size = 0\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                size += fieldType.size(data[fieldName])\n            }\n\n            return size\n        },\n\n        serialize(data: InferFieldsValues<F>) {\n            const buffer = new ArrayBuffer(this.size(data))\n            const view = new DataView(buffer)\n\n            let position = 0\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return buffer\n        },\n\n        serializeInto(view: DataView, data: InferFieldsValues<F>, position = 0) {\n            const initialPosition = position;\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return position - initialPosition\n        },\n\n        deserialize(view, position = 0) {\n            let result: Record<string, any> = {}\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                const { data, length } = fieldType.deserialize(view, position)\n\n                result[fieldName] = data\n                position += length\n            }\n\n            return result as InferFieldsValues<F>\n        }\n    }\n}\n\n\n// Field Types\n\nexport const i8 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setInt8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const u8 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setUint8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const i16 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setInt16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const u16 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setUint16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const i32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setInt32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const u32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setUint32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f64 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat64(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat64(position),\n                length: 4\n            }\n        }\n    }\n}\n\n/**\n * String field (dynamic)\n *\n * Up to 255 characters long\n *\n * @returns {Field<string>}\n */\nexport const string = (): Field<string> => {\n    return {\n        size(value): number {\n            return value.length + 1\n        },\n\n        serialize(view, position, value) {\n            view.setUint8(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 1, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 1))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 1\n            }\n        }\n    }\n}\n\n/**\n * Long String field (dynamic)\n *\n * Up to 65536 characters long\n *\n * @returns {Field<string>}\n */\nexport const longString = (): Field<string> => {\n    return {\n        size(value): number {\n            return value.length + 2\n        },\n\n        serialize(view, position, value) {\n            view.setUint16(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 2, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 2))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 2\n            }\n        }\n    }\n}\n\n/**\n * Array field (dynamic)\n *\n * Up to 255 element long\n *\n * @returns {Field<T>}\n */\nexport const array = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(value) {\n            return value.map((v) => type.size(v)).reduce((a, b) => a + b, 1)\n        },\n\n        serialize(view, position, array) {\n            view.setUint8(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset + 1\n            }\n        }\n    }\n}\n\n/**\n * Long Array field (dynamic)\n *\n * Up to 65536 element long\n *\n * @returns {Field<T>}\n */\nexport const longArray = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(value) {\n            return value.map((v) => type.size(v)).reduce((a, b) => a + b, 2)\n        },\n\n        serialize(view, position, array) {\n            view.setUint16(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset + 2\n            }\n        }\n    }\n}\n"],"names":["type","size","value","map","v","reduce","a","b","serialize","view","position","array","setUint8","length","offset","deserialize","getUint8","i","data","push","fields","fieldName","fieldType","Object","entries","buffer","ArrayBuffer","this","DataView","serializeInto","initialPosition","result","_value","setFloat32","getFloat32","setFloat64","getFloat64","setInt16","getInt16","setInt32","getInt32","setInt8","getInt8","setUint16","getUint16","chars","split","_","charCodeAt","char","String","fromCodePoint","setUint32","getUint32"],"mappings":"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"}