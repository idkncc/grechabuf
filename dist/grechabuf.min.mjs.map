{"version":3,"file":"grechabuf.min.mjs","sources":["../../grechabuf.ts"],"sourcesContent":["export interface FieldSerializeResult<T> {\n    data: T,\n    length: number\n}\n\nexport interface Field<T> {\n    /**\n     * Apoximated bytes length\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} minimal field length\n     */\n    size(view?: DataView, position?: number): number\n\n    /**\n     * Serialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     * @param value {T} value to serialize\n     *\n     * @returns {number} size of written field\n     */\n    serialize(view: DataView, position: number, value: T): number\n\n    /**\n     * Deserialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} size of written field\n     */\n    deserialize(view: DataView, position: number): FieldSerializeResult<T>\n}\n\ntype Fields = Record<string, Field<any>>\n\ntype InferFieldsValues<T extends Fields> = {\n    [K in keyof T]: T[K] extends Field<infer U> ? U : never;\n};\n\n/**\n * Struct declaration\n *\n * Used for serializing/deserializing structs\n */\nexport interface Struct<F extends Fields> {\n    /**\n     * Get size of buffer\n     *\n     * If `view` not passed, returns minimal required size of buffer (because strings have dynamic size)\n     *\n     * @returns {number} required size of buffer\n     */\n    size(view: DataView): number,\n\n    /**\n     * Serialize struct\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    serialize(view: DataView, data: InferFieldsValues<F>): number\n    deserialize(view: DataView, position?: number): InferFieldsValues<F>\n}\n\n/**\n*\n* @param fields {{[name: string]: Field }}\n* @returns {Struct} created struct declaration\n*/\nexport function createStruct<F extends Fields>(fields: F): Struct<F> {\n    return {\n        size(view?: DataView) {\n            let size = 0\n\n            for (const [_fieldName, fieldType] of Object.entries(fields)) {\n                size += fieldType.size(view, size)\n            }\n\n            return size\n        },\n\n        serialize(view: DataView, data: InferFieldsValues<F>, position = 0) {\n            const initialPosition = position;\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return position - initialPosition\n        },\n\n        deserialize(view, position = 0) {\n            let result: Record<string, any> = {}\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                const { data, length } = fieldType.deserialize(view, position)\n\n                result[fieldName] = data\n                position += length\n            }\n\n            return result as InferFieldsValues<F>\n        }\n    }\n}\n\n\n// Field Types\n\nexport const i8 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setInt8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const u8 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setUint8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const i16 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setInt16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const u16 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setUint16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const i32 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setInt32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const u32 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setUint32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f32 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f64 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat64(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat64(position),\n                length: 4\n            }\n        }\n    }\n}\n\n/**\n * String field (dynamic)\n *\n * Up to 255 characters long\n *\n * @returns {Field<string>}\n */\nexport const string = (): Field<string> => {\n    return {\n        size(view, position = 0): number {\n            if (view) {\n                return view.getUint8(position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, value) {\n            view.setUint8(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 1, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 1))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 1\n            }\n        }\n    }\n}\n\n/**\n * Long String field (dynamic)\n *\n * Up to 65536 characters long\n *\n * @returns {Field<string>}\n */\nexport const longString = (): Field<string> => {\n    return {\n        size(view, position = 0): number {\n            if (view) {\n                return view.getUint16(position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, value) {\n            view.setUint16(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 1, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 1))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 1\n            }\n        }\n    }\n}\n\n/**\n * Array field (dynamic)\n *\n * Up to 255 element long\n *\n * @returns {Field<T>}\n */\nexport const array = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(view, position = 0) {\n            if (view) {\n                return type.size(view, position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, array) {\n            view.setUint8(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset\n            }\n        }\n    }\n}\n\n/**\n * Long Array field (dynamic)\n *\n * Up to 65536 element long\n *\n * @returns {Field<T>}\n */\nexport const longArray = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(view, position = 0) {\n            if (view) {\n                return type.size(view, position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, array) {\n            view.setUint16(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset\n            }\n        }\n    }\n}\n"],"names":["createStruct","fields","size","view","_fieldName","fieldType","Object","entries","serialize","data","position","initialPosition","fieldName","deserialize","result","length","i8","_view","_position","value","setInt8","getInt8","u8","setUint8","getUint8","i16","setInt16","getInt16","u16","setUint16","getUint16","i32","setInt32","getInt32","u32","setUint32","getUint32","f32","setFloat32","getFloat32","f64","setFloat64","getFloat64","string","chars","split","map","_","i","charCodeAt","offset","char","push","String","fromCodePoint","longString","array","type","longArray"],"mappings":"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"}