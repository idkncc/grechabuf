{"version":3,"file":"grechabuf.min.mjs","sources":["../../grechabuf.ts"],"sourcesContent":["export interface FieldSerializeResult<T> {\n    data: T,\n    length: number\n}\n\nexport interface Field<T> {\n    /**\n     * Apoximated bytes length\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} minimal field length\n     */\n    size(view?: DataView, position?: number): number\n\n    /**\n     * Serialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     * @param value {T} value to serialize\n     *\n     * @returns {number} size of written field\n     */\n    serialize(view: DataView, position: number, value: T): number\n\n    /**\n     * Deserialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} size of written field\n     */\n    deserialize(view: DataView, position: number): FieldSerializeResult<T>\n}\n\ntype Fields = Record<string, Field<any>>\n\ntype InferFieldsValues<T extends Fields> = {\n    [K in keyof T]: T[K] extends Field<infer U> ? U : never;\n};\n\n/**\n * Struct declaration\n *\n * Used for serializing/deserializing structs\n */\nexport interface Struct<F extends Fields> {\n    /**\n     * Get size of buffer\n     *\n     * If `view` not passed, returns minimal required size of buffer (because strings have dynamic size)\n     *\n     * @returns {number} required size of buffer\n     */\n    size(view: DataView): number,\n\n    /**\n     * Serialize struct\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    serialize(view: DataView, data: InferFieldsValues<F>): number\n    deserialize(view: DataView, position?: number): InferFieldsValues<F>\n}\n\n/**\n*\n* @param fields {{[name: string]: Field }}\n* @returns {Struct} created struct declaration\n*/\nexport function createStruct<F extends Fields>(fields: F): Struct<F> {\n    return {\n        size(view?: DataView) {\n            let size = 0\n\n            for (const [_fieldName, fieldType] of Object.entries(fields)) {\n                size += fieldType.size(view, size)\n            }\n\n            return size\n        },\n\n        serialize(view: DataView, data: InferFieldsValues<F>, position = 0) {\n            const initialPosition = position;\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return position - initialPosition\n        },\n\n        deserialize(view, position = 0) {\n            let result: Record<string, any> = {}\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                const { data, length } = fieldType.deserialize(view, position)\n\n                result[fieldName] = data\n                position += length\n            }\n\n            return result as InferFieldsValues<F>\n        }\n    }\n}\n\n\n// Field Types\n\nexport const i8 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setInt8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const u8 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setUint8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const i16 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setInt16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const u16 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setUint16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const i32 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setInt32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const u32 = (): Field<number> => {\n    return {\n        size(_view, _position): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setUint32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint32(position),\n                length: 4\n            }\n        }\n    }\n}\n\n/**\n * String field (dynamic)\n *\n * Up to 255 characters long\n *\n * @returns {Field<string>}\n */\nexport const string = (): Field<string> => {\n    return {\n        size(view, position = 0): number {\n            if (view) {\n                return view.getUint8(position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, value) {\n            view.setUint8(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 1, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 1))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 1\n            }\n        }\n    }\n}\n\n/**\n * Array field (dynamic)\n *\n * Up to 255 element long (for more use longArray)\n *\n * @returns {Field<string>}\n */\nexport const array = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(view, position = 0) {\n            if (view) {\n                return type.size(view, position) + 1\n            } else {\n                return 1\n            }\n        },\n\n        serialize(view, position, array) {\n            view.setUint8(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset\n            }\n        }\n    }\n}\n"],"names":["createStruct","fields","size","view","_fieldName","fieldType","Object","entries","serialize","data","position","initialPosition","fieldName","deserialize","result","length","i8","_view","_position","value","setInt8","getInt8","u8","setUint8","getUint8","i16","setInt16","getInt16","u16","setUint16","getUint16","i32","setInt32","getInt32","u32","setUint32","getUint32","string","chars","split","map","_","i","charCodeAt","offset","char","push","String","fromCodePoint","array","type"],"mappings":"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"}