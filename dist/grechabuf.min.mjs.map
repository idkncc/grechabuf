{"version":3,"file":"grechabuf.min.mjs","sources":["../../grechabuf.ts"],"sourcesContent":["export interface FieldSerializeResult<T> {\n    data: T,\n    length: number\n}\n\nexport interface Field<T> {\n    /**\n     * Calculate byte size\n     *\n     * @param value {T} value\n     *\n     * @returns {number} minimal field length\n     */\n    size(value: T): number\n\n    /**\n     * Serialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     * @param value {T} value to serialize\n     *\n     * @returns {number} size of written field\n     */\n    serialize(view: DataView, position: number, value: T): number\n\n    /**\n     * Deserialize field\n     *\n     * @param view {DataView} data view\n     * @param position {number} AKA offset\n     *\n     * @returns {number} size of written field\n     */\n    deserialize(view: DataView, position: number): FieldSerializeResult<T>\n}\n\ntype Fields = Record<string, Field<any>>\n\ntype InferFieldsValues<T extends Fields> = {\n    [K in keyof T]: T[K] extends Field<infer U> ? U : never;\n};\n\n/**\n * Struct declaration\n *\n * Used for serializing/deserializing structs\n */\nexport interface Struct<F extends Fields> {\n    /**\n     * Calculate size of buffer\n     *\n     * @returns {number} size of buffer\n     */\n    size(data: InferFieldsValues<F>): number,\n\n    /**\n     * Serialize struct, returning with new ArrayBuffer\n     *\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {ArrayBuffer} serialized data\n     */\n    serialize(data: InferFieldsValues<F>): ArrayBuffer\n\n    /**\n     * Serialize struct into data view\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    serializeInto(view: DataView, data: InferFieldsValues<F>): number\n\n    /**\n     * Deserialize struct from data view\n     *\n     * @param view {DataView} data view\n     * @param data {InferFieldsValues<F>} data to serialize\n     *\n     * @returns {number} length of serialized data\n     */\n    deserialize(view: DataView, position?: number): InferFieldsValues<F>\n}\n\n/**\n*\n* @param fields {{[name: string]: Field }}\n* @returns {Struct} created struct declaration\n*/\nexport function createStruct<F extends Fields>(fields: F): Struct<F> {\n    return {\n        size(data: InferFieldsValues<F>) {\n            let size = 0\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                size += fieldType.size(data[fieldName])\n            }\n\n            return size\n        },\n\n        serialize(data: InferFieldsValues<F>) {\n            const buffer = new ArrayBuffer(this.size(data))\n            const view = new DataView(buffer)\n\n            let position = 0\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return buffer\n        },\n\n        serializeInto(view: DataView, data: InferFieldsValues<F>, position = 0) {\n            const initialPosition = position;\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                position += fieldType.serialize(view, position, data[fieldName])\n            }\n\n            return position - initialPosition\n        },\n\n        deserialize(view, position = 0) {\n            let result: Record<string, any> = {}\n\n            for (const [fieldName, fieldType] of Object.entries(fields)) {\n                const { data, length } = fieldType.deserialize(view, position)\n\n                result[fieldName] = data\n                position += length\n            }\n\n            return result as InferFieldsValues<F>\n        }\n    }\n}\n\n\n// Field Types\n\nexport const i8 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setInt8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const u8 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setUint8(position, value)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint8(position),\n                length: 1\n            }\n        }\n    }\n}\n\nexport const i16 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setInt16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const u16 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 2\n        },\n        serialize(view, position, value) {\n            view.setUint16(position, value)\n            return 2\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint16(position),\n                length: 2\n            }\n        }\n    }\n}\n\nexport const i32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setInt32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getInt32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const u32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setUint32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f32 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat32(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat32(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const f64 = (): Field<number> => {\n    return {\n        size(_value): number {\n            return 4\n        },\n        serialize(view, position, value) {\n            view.setFloat64(position, value)\n            return 4\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getFloat64(position),\n                length: 4\n            }\n        }\n    }\n}\n\nexport const bool = (): Field<boolean> => {\n    return {\n        size(_value): number {\n            return 1\n        },\n        serialize(view, position, value) {\n            view.setUint8(position, value ? 0xFF : 0x00)\n            return 1\n        },\n        deserialize(view, position) {\n            return {\n                data: view.getUint8(position) > 0x55,\n                length: 1\n            }\n        }\n    }\n}\n\n/**\n * String field (dynamic)\n *\n * Up to 255 characters long\n *\n * @returns {Field<string>}\n */\nexport const string = (): Field<string> => {\n    return {\n        size(value): number {\n            return value.length + 1\n        },\n\n        serialize(view, position, value) {\n            view.setUint8(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 1, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 1))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 1\n            }\n        }\n    }\n}\n\n/**\n * Long String field (dynamic)\n *\n * Up to 65536 characters long\n *\n * @returns {Field<string>}\n */\nexport const longString = (): Field<string> => {\n    return {\n        size(value): number {\n            return value.length + 2\n        },\n\n        serialize(view, position, value) {\n            view.setUint16(position, value.length)\n\n            const chars = value\n                .split(\"\")\n                .map((_, i) => [i, value.charCodeAt(i)])\n            for (const [offset, char] of chars) {\n                view.setUint8(position + offset + 2, char)\n            }\n\n            return value.length + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n            let chars = []\n\n            for (let offset = 0; offset < length; offset++) {\n                chars.push(view.getUint8(position + offset + 2))\n            }\n\n            return {\n                data: String.fromCodePoint(...chars),\n                length: length + 2\n            }\n        }\n    }\n}\n\n/**\n * Array field (dynamic)\n *\n * Up to 255 element long\n *\n * @returns {Field<T>}\n */\nexport const array = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(value) {\n            return value.map((v) => type.size(v)).reduce((a, b) => a + b, 1)\n        },\n\n        serialize(view, position, array) {\n            view.setUint8(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint8(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset + 1\n            }\n        }\n    }\n}\n\n/**\n * Long Array field (dynamic)\n *\n * Up to 65536 element long\n *\n * @returns {Field<T>}\n */\nexport const longArray = <T>(type: Field<T>): Field<T[]> => {\n    return {\n        size(value) {\n            return value.map((v) => type.size(v)).reduce((a, b) => a + b, 2)\n        },\n\n        serialize(view, position, array) {\n            view.setUint16(position, array.length)\n\n            let offset = 0\n            for (const value of array) {\n                offset += type.serialize(view, position + offset + 1, value)\n            }\n\n            return offset + 1\n        },\n\n        deserialize(view, position) {\n            const length = view.getUint16(position)\n\n            let array = []\n            let offset = 0\n            for (let i = 0; i < length; i++) {\n                const { data, length } = type.deserialize(view, position + offset + 1)\n                array.push(data)\n                offset += length\n            }\n\n            return {\n                data: array,\n                length: offset + 2\n            }\n        }\n    }\n}\n"],"names":["createStruct","fields","size","data","fieldName","fieldType","Object","entries","serialize","buffer","ArrayBuffer","this","view","DataView","position","serializeInto","initialPosition","deserialize","result","length","i8","_value","value","setInt8","getInt8","u8","setUint8","getUint8","i16","setInt16","getInt16","u16","setUint16","getUint16","i32","setInt32","getInt32","u32","setUint32","getUint32","f32","setFloat32","getFloat32","f64","setFloat64","getFloat64","bool","string","chars","split","map","_","i","charCodeAt","offset","char","push","String","fromCodePoint","longString","array","type","v","reduce","a","b","longArray"],"mappings":"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"}